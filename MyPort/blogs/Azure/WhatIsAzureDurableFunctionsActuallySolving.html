<!DOCTYPE html>
<html>
  <head>
    <script
      async
      src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"
    ></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-2264462236439566",
        enable_page_level_ads: true,
      });
    </script>
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script
      async
      src="https://www.googletagmanager.com/gtag/js?id=UA-131742548-1"
    ></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag() {
        dataLayer.push(arguments);
      }
      gtag("js", new Date());

      gtag("config", "UA-131742548-1");
    </script>
    <script src="../../vendor/jquery/jquery.min.js"></script>
    <script src="../../js/prism.js"></script>

    <script>
      $(document).ready(function () {
        $(".header").load("../../baseheader.html", function () {
          setTimeout(
            $("#headermenu").load("../../header.html #menu", function () {}),
            250
          ); // try diff. values
        });
      });
    </script>

    <meta charset="utf-8" />
    <meta name="robots" content="all,follow" />
    <meta name="googlebot" content="index,follow,snippet,archive" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>SManju</title>

    <meta name="keywords" content="" />
    <link
      href="http://fonts.googleapis.com/css?family=Roboto+Slab:400,700,100%7CRoboto:400,700,300,100"
      rel="stylesheet"
      type="text/css"
    />
    <!-- Bootstrap and Font Awesome css -->
    <link
      rel="stylesheet"
      href="../../vendor/bootstrap/css/bootstrap.min.css"
    />
    <!-- Font Awesome CSS-->
    <link
      rel="stylesheet"
      href="../../vendor/font-awesome/css/font-awesome.min.css"
    />
    <link rel="stylesheet" href="../../css/style.default.css" />
    <link rel="stylesheet" href="../../css/prism.css" />
  </head>

  <body>
    <div id="fb-root"></div>
    <script
      async
      defer
      src="https://connect.facebook.net/en_GB/sdk.js#xfbml=1&version=v3.2"
    ></script>

    <!-- *** NAVBAR ***
_________________________________________________________ -->
    <header class="header"></header>
    <!-- /#navbar -->

    <br />
    <section class="about-section">
      <div class="container">
        <div class="row">
          <div class="col-sm-12 themed-grid-col">
            <h3>
              Azure Durable Functions- What are these and why we need them
              <span style="font-size: 12px; color: blueviolet"
                >10th June 2021</span
              >
            </h3>

            <img
              src="DurableFunctionBasics/0heading.png"
              alt="heading"
              class="img-fluid"
            />
            <p>
              Stateful Workflows on top of Stateless Serverless Cloud Functions
              ‚Äî this is the essence of the Azure Durable Functions library.This
              is the one line definition of Azure durable functions.But then
              this is lot of fancy words in one sentence, and they might be hard
              for the majority of readers to understand.Let's see a little
              background of web applications and then we will see where Azure
              Durable functions fit in
              <!--<a
                href="https://scripts.affiliatefuture.com/AFClick.asp?affiliateID=349397&merchantID=7252&programmeID=26550&mediaID=169980&tracking=&afsource=10&url="
                ><img
                  border="0"
                  src="https://banners.affiliatefuture.com/7252/169980.jpg"
              /></a>-->
            </p>
            <h6>Monolith and Microservices</h6>
            <p>
              Originally, server-side applications were built in a style which
              is now referred to as <b>Monolith</b>. A monolithic application is
              built as a single unit.Enterprise Applications are built in three
              parts: a database (mostly relational database), a client-side user
              interface (HTML,Javascript on browser), and a server-side
              application(Eg C#,Java etc). This server-side application will
              handle HTTP requests, execute some business domain logic,
              retrieve/update data from/to database, and finally populate the
              HTML views to be sent back to the client's
              browser(Chrome,Firefox,IE etc). It is a monolith ‚Äì a single
              logical executable. To make any alterations to the system, a
              developer must build and deploy an updated version of the
              server-side application.If multiple people and teams were
              developing parts of the same application, they mostly contributed
              to the same code base.
            </p>
            <p>
              If the teams follow coding and design practises well, code base
              would be structured well and it would have some distinct modules
              or components, and a single team would typically own each
              module.Normally, the modules would be packaged together at build
              time and then deployed as a single unit, so a lot of interaction
              between modules would stay inside the OS process. Although the
              modules could stay loosely coupled, over a period of time, since
              all teams would use a single centralized database, the coupling
              almost always occurs on the level of the data store . This model
              works great for small- to medium-size applications, but as the
              team number swells,it turns out that teams start getting in each
              other‚Äôs way as synchronization of contributions takes more and
              more effort.<br />

              Monolith approach Eg in diagram below <br />
              <img
                border="0"
                src="DurableFunctionBasics/monolithapproach.jpg"
                alt="monolith"
              />
              <br />
              As an alternative, and as industry evolved, there was this new
              approach which came up with a revised service-oriented strategy
              commonly called <b>Microservices</b>. In this approach,teams split
              the big application into ‚Äúvertical slices‚Äù structured around the
              distinct business capabilities.Microservice capabilities are
              expressed formally with business-oriented APIs.Each microservice
              encapsulate a core business capability and the same service can be
              reused in more than one business processes(and thats the beauty if
              microservices) or over different business sceanrios, depending on
              the requirement. By ensuring that principles of loose coupling are
              followed and implemented, dependencies between services and their
              consumer are kept to minimal.Services talk to each other via
              documented and versioned public contracts.If microservices‚Äô
              interfaces are exposed with a standard protocol, such as a
              REST-ful API, they can be consumed and reused by other services
              and applications without direct coupling through language bindings
              or shared libraries. If the borders for the split were selected
              well‚Äîand that‚Äôs the most tricky part‚Äîthe contracts are standarized
              and stay stable over time, and thin enough to avoid too much
              chattiness then team can change the implementation of the
              service,and consumers wont be affected by changes .This gives each
              team enough autonomy to innovate at their best pace and to make
              independent technical decisions.
            </p>
            <p>
              In microservices approach,each team then owns a whole
              vertical‚Äîfrom communication contracts, or even UIs, down to the
              data storage. Explicitly shared databases are not recommended at
              all.There are few drawbacks of microservices as well.<br />
              <img
                border="0"
                src="DurableFunctionBasics/microservices.jpg"
                alt="microservices"
              /><br />
              The tradeoff of this flexibility is complexity. Managing a
              multitude of distributed services at scale is difficult for the
              following reasons:
            </p>
            <b>Trade offs:</b><br />
            <h6 style="display: inline">1).</h6>
            <p style="display: inline">
              Teams need to easily discover services as potential resuse
              candidates.We all know resuing services is easier than building
              from scratch, but for that to happen these services should be well
              documented etc.
            </p>
            <br />
            <h6 style="display: inline">2).</h6>
            <p style="display: inline">
              Interdependencies between services need to be closely monitored.If
              not architectured well, an application based on microservices
              might end up being a distributed monolith. In such scenario,
              microservices are chatty, sometimes calling each other and
              defeating the main purpose.Changes to one microservice required
              changes to others(becomes highly coupled).
            </p>
            <h6 style="display: inline">3).</h6>
            <p style="display: inline">
              Services interact with each other through networks. Networks are
              fundamentally unreliable.They work fine most of the times,but when
              they fail it fails in all kinds of unpredictable manner.Yeah
              network sometime takes break üòä <br />
              <br />
              <img
                border="0"
                style="margin-left: 10%"
                src="DurableFunctionBasics/networkfailure.jpg"
                alt="microservices"
              /><br /><br />
              Imagine a scenario when one service goes unhealthy and is down.It
              can go offline for multiple reasons, for instance say a new
              version of service is being deployed,or may be there are plenty of
              requests coming in and it cant handle the request load etc.The
              problem is that all the requests to this failed/down service start
              failing.The dependent service waits for the response and thus
              blocks incoming requests of its own.You can probably guess where
              it is heading.The error cascades upstream and there are failures
              all over the place.The application is down. Your manager ofcourse
              is not happy. Lets quickly look at above scenario through a
              diagram<br />
              <img
                style="margin-left: 10%"
                src="DurableFunctionBasics/basicrestapproach.jpg"
                alt="analogy"
                class="img-fluid"
              /><br /><br />
              <b
                >Issues with this approach even though your application will
                work properly:</b
              >
              <br />
            </p>

            <h6 style="display: inline">1).</h6>
            <p style="display: inline">
              Module A makes a request to Module B and waits for the response
            </p>
            <br />
            <h6 style="display: inline">2).</h6>
            <p style="display: inline">
              Module B may be down, offline or simply slow.
            </p>
            <br />
            <h6 style="display: inline">3).</h6>
            <p style="display: inline">
              Network delays may further decrease performance.If data is
              humongous, then it means there will be more REST calls
            </p>
            <br />
            <h6 style="display: inline">4).</h6>
            <p style="display: inline">
              Module B will be under heavy load,and can respond very late
            </p>
            <br />
            <p style="display: inline">
              Above scenario,where your system becomes less efficient because
              you have a synchronous API, is a perfect use case where you can
              apply event-driven solution
            </p>
            <br />
            <br />
            <h6>Event-Driven Microservice</h6>
            <p>
              <img
                style="margin-left: 10%"
                src="DurableFunctionBasics/microserviceseventdriven.jpg"
                alt="analogy"
                class="img-fluid"
              /><br /><br />
            </p>

            <p>
              In an event-driven microservice architecture, services communicate
              each-other via <b>event messages</b>. When a service performs some
              piece of work that other services might be interested in, that
              service produces an event. Other services consume them through
              event listeners and perform any of their own tasks.
            </p>

            <img
              src="DurableFunctionBasics/serviceeventdriven.jpg"
              alt="eventdriven"
              class="img-fluid"
            /><br /><br />
            <p>
              The service that produces events,i.e publisher in this case, might
              not know about the consumers. Also, added advantage of this
              approach is that new event subscribers can be added over time.Lets
              consider a <b>simple egample</b>. Suppose you go to your favorite
              ecommerce website, and make an order.This single
              <b>order placed</b> event is produced and then will be consumed by
              several listening microservices:
            </p>
            <h6 style="display: inline">1).</h6>
            "Order" service may write an order to the database <br />
            <h6 style="display: inline">2).</h6>
            "Customer" service could create the customer record <br />
            <h6 style="display: inline">3).</h6>

            "Inventory" service may update the inventory available in the
            warehouse
            <p>
              <br />
              Events can be published in variety of ways.For example, they can
              be published to a queue which in turn takes care of the deliver of
              the event to the right consumer, or they can be published to a
              ‚Äúpub/sub‚Äù model stream that in turn publishes the event and all
              interested parties access them. Whatever be the case, the producer
              publishes the event, and the consumer receives that event.Few
              advantages of event driven architecture are listed below:
            </p>
            <h6 style="display: inline">1).</h6>
            <b>Asynchronous</b> - Ensures that one service doesn't block
            other.This allows resources to move freely to the next task once
            their execution is complete, without worrying about what happened
            before or will happen next. If one service is down, other services
            don‚Äôt catch fire immediately. The upstream services keep publishing
            the events, which add to the queue but can be stored safely for
            hours or days. The downstream services can stay healthy too. Since
            events are queued/buffered,it helps in reducing request
            overload.With a queue in place,lost work can be recovered by
            "replaying" events from the past <br />
            <h6 style="display: inline">2).</h6>
            <b>"Loose Coupling"</b> is another biggest advantage.Services should
            not have any knowledge of other services,also also should not
            dependent on other services.With events,services are supposed to
            operate independently.Services under an event model can be
            updated,tested and deployed independently and therefore more easily
            <br />
            <h6 style="display: inline">3).</h6>
            <p>
              <b>"Performance improvement"</b> is another plus. Since services
              are less coupled & are supposed to perform only one task,tracking
              down bottlenecks to a specific service is relatively easy.Once the
              service in question is identified, we can scale that particular
              service.
            </p>
            <p>
              Like any other architecture, its not all hunky-dory with this
              architecture too. There are drawbacks:
            </p>

            <h6 style="display: inline">1).</h6>
            One issue that comes hand-in-hand with loose coupling is low
            cohesion.Given many components that publish and subscribe to a large
            number of event types, it‚Äôs easy to stop seeing the forest for the
            trees. i.e you may not understand the high-level flow and therefore
            becomes tougher to contol the system behaviour as the app grows. The
            very advantage(loose coupling/flexibility) becomes disadvantage as
            the complexity increases when there are more microservices.The
            reason is that one event triggers a range of services, and with more
            events it becomes pretty unpredictable.An event driven architecture
            is easy to develop but hard to control.<br />
            <h6 style="display: inline">2).</h6>
            Other significant drawback and challenge is data and transaction
            management. Since they are of asynchronous nature,there is a
            possibility of inconsistent data between services,duplicate events
            etc which means there is no support for ACID
            transactions.Instead,there is support for
            <b>eventual consistency</b> which can be more difficult to track or
            debug.
            <br />
            <br />
            <h6>Cloud and Serverless</h6>
            <p>
              <img
                style="margin-left: 10%"
                src="DurableFunctionBasics/cloudandnetwork.jpg"
                alt="analogy"
                class="img-fluid"
              /><br /><br />

              Image from
              <span style="font-size: 12px">
                <a href="https://favpng.com/">favpng</a></span
              >
            </p>
            <p>
              Rise of cloud changed the way we designed applications. Public
              cloud is the paramount distributed system and no doubt these
              systems are hard.Having said that lot many things became easier
              with cloud.<br /><b>Benefits include</b>:
            </p>
            <h6 style="display: inline">1).</h6>
            Provisioning of new resources now just take minutes (which earlier
            would have taken months) <br />
            <h6 style="display: inline">2).</h6>
            There is more flexibility which means more control over capacity and
            leads to scalabilty<br />
            <h6 style="display: inline">3).</h6>
            Reduced IT costs<br />
            <h6 style="display: inline">4).</h6>
            Resiliency and disaster recovery at the global scale
            <br />
            <br />
            <p>
              There are various reasons to deploy applications to multiple
              geographic locations. First thing being, with customers needing
              faster websites/applications like never before, if you stay closer
              to the customer,there is <b>reduced network latency</b> which
              therefore helps the cause.And you can also achieve
              <b>resilience</b> through <b>geographical redundancy</b>.There are
              2 keywords to understand in the above sentence. One being
              <b>resilience</b> which refers to the ability to continue
              operating when there has been an failure,irrespective of what kind
              and <b>redundancy</b> means the level of backup that can take over
              when the primary equipment or infrastructure fails.
            </p>
            <p>
              And there is more to think about.Each cloud provider has tons of
              managed services, which has its own prons and cons. Prons being
              that specialized services are best to provide off-the-shelf
              solutions to common complex problems.Btw, Off-the-shelf here means
              that we have standard solutions to problems which others might
              have faced.On the flip side,each service has distinct properties
              w.r.t resiliency, fault tolerance and consistency.
            </p>
            <b>Serverless</b><br />
            <p>
              When I first heard the word serverless few years back, I was
              confused and not sure what exactly it meant.So dont be perplexed
              if you are not sure either.Just hang on and you should get it by
              end of the article .<b>Serverless</b> is a way to describe the
              services, practices, and strategies that enable you to build more
              agile applications.It's a term that is used to descirbe cloud
              services that do not require provisioning of VMs, instances, etc.
              All you need to worry about is writing code that serves your
              customers.Resources are allocated dynamically and transparently,
              and the cost is based on their actual consumption, rather than on
              pre-purchased capacity.
            </p>
            <p>
              Also donot think that serverless means servers donot exist. They
              do exist but its been taken care by someone else.You don't manage
              the uptime of serverless applications:your cloud provider does.
            </p>
            <p>
              Best thing about this is that you pay for what you use.This is
              beneficial in most scenarios for eveyrone and even more for
              startups because they dont want to invest in hardware upfront.It
              is more like pay as you go.Also, you abstract away the
              hardware,scalibility part etc to the cloud provider.Somewhat like
              what you do with gas to heat up your house. You dont setup a
              powerplant but instead you buy gas from your energy provider and
              pay as per their billing cycle.
            </p>
            <p>
              Serverless compute does the same: it supplies standard services on
              a pay-per-use basis. Often, serverless computing is also referred
              to as <b> Function-as-a-Service (FaaS)</b>. For instance, Azure
              offers Azure functions,and what it allows us to do is run small
              pieces of code in the cloud.It enables us to run event-triggered
              code without having to provision or manage infrastructure.So all
              we need to focus is on the pieces of code that matters and
              Fuctions handle the rest.Azure Functions scale based on demand and
              you pay only for the resources you consume.So.. No usage‚Äîno
              bill.Isn't that fantastic?
            </p>
            <p>
              And then there is always some "But". FaaS services come with some
              terms and conditions that applications have to follow:
            </p>
            <ul style="display: inline">
              <li class="liStyleWithoutDots" style="margin-top: -2%">
                <b>Quick runs</b>: Functions can only run up to several minutes,
                and its advised for a few seconds or less;
              </li>
              <li class="liStyleWithoutDots">
                <b>Event-Driven</b>: For each serverless function you have to
                define a specific trigger i.e functions can only be triggered by
                an event which can occur in virtually any Azure or 3rd party
                service as well as on-premises systems.Being as a trigger-based
                service, it runs a script or piece of code in response to a
                variety of events.
              </li>
              <li class="liStyleWithoutDots">
                <b>Stateless</b>: Since infrastructure is taken care by the
                cloud provider, you can't control where and when function
                instances are provisioned or deprovisioned, and hence there is
                no way to store data unless ofcourse you use external
                storage.You may wonder why do you need to maintain state
                afterall, so lets discuss that below with an egample
              </li>
            </ul>

            <!--    <ul style="display: inline">
              <li class="liStyleWithoutDots" style="margin-top: -2%">
                <b>1 REST APIs)</b> - Stands for Representational State
                Transfer. <br />
                <img
                  src="apiandschema/restapi.jpg"
                  alt="api"
                  class="img-fluid"
                /><br /><br />
                It is an architectural style. The
                <b>REST architecture</b> generally consists of clients, servers,
                resources, and a vocabulary of HTTP operations known as
                <b>request methods</b>. REST relies on principles that are
                ultimately simpler to follow than a prescribed protocol. Most of
                the API's specially Public API's use REST standard these days
                specifically because of its fast performance, reliability, and
                ability to scale by reusing modular components without affecting
                the system as a whole.<br />From developer point of view, REST
                is a set of rules that they need to follow when they create
                their API.<br />
                One of the rules states that you should be able to get a piece
                of data (called a resource) when you link to a specific URL.<b
                  >Each URL</b
                >
                is called a <b>request</b> while the <b>data sent back</b> to
                you is called a <b>response</b>.<br />The <b>payload</b> - the
                data to be delivered (i.e the response) - will be
                <b>formatted in a language</b>
                such as <b>JSON</b>, or <b>XML</b>.<br />The
                <b>set of operations</b>
                are the methods available to HTTP, which is the underlying
                protocol for how browsers retrieve websites from servers. These
                methods include
                <b>GET, POST, PUT, DELETE, and others</b>.<br />And thats why
                it's easier for developer because even if they don't know
                specifics of REST, they are likely to know how to work with
                RESTful APIs thanks to the underlying foundation upon which they
                are built: HTTP.<br /><br />
                <h5>The Anatomy Of A REST API Request</h5>
                <h6 style="display: inline">A).</h6>
                <p style="display: inline">
                  <b>URI (uniform resource identifier)</b>, which is the URL
                  address, also known as an ‚Äúendpoint‚Äù).The endpoint (or route)
                  is the url you request for. It follows this structure:
                  https://blog.postman.com/rest-api-examples/
                  https://cat-fact.herokuapp.com/facts/. The root-endpoint is
                  the starting point of the API you‚Äôre requesting from. The
                  root-endpoint of Github‚Äôs API is https://api.github.com while
                  the root-endpoint Twitter‚Äôs API is https://api.twitter.com.
                </p>
                <br />
                <h6 style="display: inline">B).</h6>
                <p style="display: inline">
                  The method i.e <b>HTTP Verbs </b>like GET - for retrieving the
                  details, POST-for insertion, PUT -for updating, DELETE - for
                  deletion
                </p>
                <br />
                <h6 style="display: inline">C).</h6>
                <p style="display: inline">
                  <b>Headers</b>- like authentication tokens,data format of
                  request (mainly when you do a PUT/POST) (eg application/json)
                </p>
                <br />
                <h6 style="display: inline">D).</h6>
                <p style="display: inline"><b>Body</b> which is the data</p>
                <br />
              </li>
              <br />
              <br />

              <li class="liStyleWithoutDots" style="margin-top: -2%">
                <b>2 SOAP APIs)</b> stands for ‚ÄúSimple Object Access Protocol,‚Äù
                <br />
                <img
                  src="apiandschema/soapapi.png"
                  alt="api"
                  class="img-fluid"
                /><br /><br />
                This is more complex than REST because it requires more
                information upfront about security and how to sends messages.
                SOAP, unlike the REST pattern, supports the XML data format only
                and strongly follows preset standards such as messaging
                structure, a set of encoding rules, and a convention for
                providing procedure requests and responses and therefore to lack
                the lightweight portability and flexibility of REST.SOAP was
                developed to help standardize message formats and requests.SOAP
                API's are still used specially it can assist in certain
                scenarios better. For instance, if you need more robust
                security, SOAP‚Äôs support for WS-Security can come in handy. SOAP
                can be extended with WS standard protocols. Another advantage of
                SOAP is that it offers built-in retry logic to compensate for
                failed communications. REST, on the other hand, doesn‚Äôt have a
                built-in messaging system. If a communication fails, the client
                has to deal with it by retrying. There‚Äôs also no standard set of
                rules for REST. SOAP is highly extensible through other
                protocols and technologies. In addition to WS-Security, SOAP
                supports WS-Addressing, WS-Coordination, WS-ReliableMessaging,
                and a lot of other web services standards. You can find full
                list on W3C
              </li>
            </ul>
            <br /> -->
            <br />
            <h6>Challenges of Serverless model</h6>
            <p>
              Let's consider a hypothetical scenario where in our Web
              Application will book tickets to tech symposium.Assume tech
              symposium is in another city and you can get there by bus.Also
              since you might have to say there overnight,you need to book an
              accomodation. Therefore, our web application will take care of
              booking tech symposium tickets,reserving seat on the bus and
              booking hotel accomodation itself
            </p>
            <p>
              <img
                style="margin-left: 10%"
                src="DurableFunctionBasics/scenario.jpg"
                alt="analogy"
                class="img-fluid"
              /><br /><br />
            </p>
            <p>
              In above sceanario, you can clearly see that there are 3 major
              steps.
            </p>
            <h6 style="display: inline">1).</h6>
            Book tech symposium tickets <br />
            <h6 style="display: inline">2).</h6>
            Reserve a seat on the bus
            <br />
            <h6 style="display: inline">3).</h6>
            Book a hotel <br />
            <p>
              Each step above,can have it's own Azure function.A standard
              function is best thought of as a software switch- takes data from
              one input,processes it and then takes appropriate action. It can
              also emits an event which the next function can listen for.Now all
              of that looks good under normal conditions.But then there are few
              questions which arises and we need to answer/handle
            </p>
            <h6 style="display: inline">
              What about sequencing- Is above really decoupled?
            </h6>
            <p>
              <img
                style="margin-left: 10%"
                src="DurableFunctionBasics/parallelactions.jpg"
                alt="analogy"
                class="img-fluid"
              /><br /><br />
            </p>
            <p>
              In above eg, we had 3 steps which executed in sequence. Each task
              is independent of each other and can run on its own.But even then,
              as you can see in above picture, the function's sequence is kind
              of predefined and that leads to coupling.If, for instance, we swap
              the order of reserving seat on bus with booking accomodation, that
              would require a code change‚Äîat least of the input/output wiring
              definitions.
            </p>
            <h6 style="display: inline">
              Can we run these functions parallely?
            </h6>
            <p>
              This is where we left above. We know that all these tasks are
              independent of each other.But renociliation of outputs of each
              task is the challenge.Like for instance, say your manager wants to
              know how much did the whole trip cost to the company. <br />
              Like in above picture, both <b>Book Bus</b> and
              <b> Book accomodation</b> are listening to the same event.Once
              they receive that event,they get on with their individual tasks
              and complete it. But like mentioned above, there is no way to
              implement "how much did it cost the company" as a single azure
              function because functions can't be triggered by two events.So we
              might have to use a <b>shared storage</b>.Complexity grows
              multifold if there are more tasks running in parallel
            </p>
            <h6 style="display: inline">
              What if some third party service falls over-Error handling
            </h6>
            <p>
              Now above we did mention that our application reserves a seat on
              bus. Now assume the reserving seat on a bus system is down(some
              third party application).To make things complex we dont have a
              control over the third party app and therefore dont know when it
              will be back. In normal scenario, retries may happen almost
              immediately but that may not be ideal in this situation.What we
              need is probably an <b>exponential back-off policy</b>.Exponential
              backoff is a standard error-handling strategy for network
              applications. In this approach, a client periodically retries a
              failed request with increasing delays between requests.<br />
              But to implement that next attempt need to know history of
              attempts and again we need to persist that somewhere.In the above
              hypothetcial web application egample, if the workflow is made
              little more complex, there may be a scenario that if for some
              reason reserving a seat on bus fails,then application need to book
              a cab.So what it means is that when there is an error, we might
              have to run some compensating logic.
            </p>
            <p>
              All the above scenarios, either that be error handling or parallel
              actions, needs some storage/shared space.Unfortunately,Azure
              functions are stateless and therefore are not aware of bigger
              picture, while workflows like these require a state to keep track
              of their progress. Therefore they are not aware of bigger picture.
              Now with all these points in mind, we know where we are heading
              to.We need someone to take care of the state and that is where
              <b>Microsoft Azure Durable Functions</b> came into play.In fact,
              this is an extension that allows you to write stateful functions
              that manage state, errors, restarts etc. Durable functions allows
              us to organise low-level single-purpose independent functions into
              high-level workflows.Since Durable functions offer a way to
              orchestrate other functions, they can help to create workflows in
              which status is saved automatically using storage. Oh, and they
              have a history too!
            </p>
            <h6 style="display: inline">Conclusion.</h6>
            <p style="display: inline">
              To conclude,I hope you understand what are API's, it's usage and
              types of API.Do refer my blog to understand API-schema. Link
              belowLink below <br />
              <a href="what-is-api-schema.html">What is API-Schema</a>
            </p>
          </div>
        </div>

        <div class="row">
          <div class="col-sm-9 themed-grid-col">
            <p>
              And that's it. Hope you undertood how to customize JSON server.
              .Email me at "techspacedeck@gmail.com" incase you have queries.
              Alternatively, you can fill the "CONTACT" form or drop a comment
              below
            </p>
          </div>
        </div>
        <a href="https://www.buymeacoffee.com/manjus"
          ><img
            src="https://img.buymeacoffee.com/button-api/?text=Buy me a coffee&emoji=&slug=manjus&button_colour=FFDD00&font_colour=000000&font_family=Cookie&outline_colour=000000&coffee_colour=ffffff"
        /></a>
      </div>
    </section>
    <section style="padding: 10px !important">
      <div class="container">
        <h4>
          Did you like the blog or have questions, please add your comments
        </h4>
        <div id="graphcomment"></div>
        <script type="text/javascript">
          /* - - - CONFIGURATION VARIABLES - - - */

          // make sure the id is yours
          window.gc_params = {
            graphcomment_id: "www-manjustechblog-com",

            // if your website has a fixed header, indicate it's height in pixels
            fixed_header_height: 0,
          };

          /* - - - DON'T EDIT BELOW THIS LINE - - - */

          (function () {
            var gc = document.createElement("script");
            gc.type = "text/javascript";
            gc.async = true;
            gc.src =
              "https://graphcomment.com/js/integration.js?" +
              Math.round(Math.random() * 1e8);
            (
              document.getElementsByTagName("head")[0] ||
              document.getElementsByTagName("body")[0]
            ).appendChild(gc);
          })();
        </script>
      </div>
    </section>
    <!-- /#navbar -->
    <footer class="main-footer">
      <div class="container">
        <div class="row">
          <div class="col-md-6 text-center text-lg-left">
            <p class="social">
              <a
                href="http://www.facebook.com/shenoyvnm
                            "
                class="external facebook wow fadeInUp"
                ><i class="fa fa-facebook"></i
              ></a>
              <a
                style="background-color: grey"
                href="http://www.linkedin.com/in/manjunathshenoywebdev"
                class="external linkedin wow fadeInUp"
                ><i class="fa fa-linkedin"></i
              ></a>
            </p>
          </div>

          <!-- /.6-->
          <div class="col-md-6 text-center text-lg-right mt-4 mt-lg-0">
            <p>¬© 2018 SManju. All rights reserved.</p>
          </div>
          <div class="col-12 mt-4">
            <p class="template-bootstrapious">
              Designed by
              <a href="https://www.bootstrapious.com">Bootstrapious</a>
              <!-- Please do not remove the backlink to us unless you support further theme's development at https://bootstrapious.com/donate. It is part of the license conditions. Thank you for understanding :)-->
            </p>
          </div>
        </div>
      </div>
    </footer>
    <!-- JavaScript files-->
    <script src="../../vendor/bootstrap/js/bootstrap.min.js"></script>
  </body>
</html>
